<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>-- --- .-. .-- ... .</title>
    <style>
      body {
        background-color: #1a1a1a;
        color: #ffffff;
        font-family: 'Courier New', monospace;
        margin: 0;
        padding: 1rem;
      }

      pre {
        text-align: left;
        margin: 0;
        color: #808080;
        float: left;
      }

      .mode-display {
        position: fixed;
        top: 1rem;
        right: 1rem;
      }

      .user-list {
        position: fixed;
        top: 0;
        right: 1rem;
        z-index: 1001;
        padding-top: 1rem;
      }

      .user-item {
        align-items: center;
        margin-bottom: 0.2rem;
        font-size: 14px;
        font-family: 'Courier New', monospace;
      }

      .user-item:last-child {
        margin-bottom: 0;
      }

      .user-name {
        color: #00ff00;
        min-width: 120px;
        text-align: right;
      }

      .current-user .user-name {
        font-weight: bold;
        color: #ffffff;
      }

      .user-morse-canvas {
        position: absolute;
        right: 100%;
        width: calc(100vw - 140px);
        height: 4px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 999;
        pointer-events: none;
        margin-right: 10px;
      }

      .user-item {
        position: relative;
      }

       .center-circle {
         position: fixed;
         top: 50%;
         left: 50%;
         transform: translate(-50%, -50%);
         width: 100px;
         height: 100px;
         background-color: #006600;
         border-radius: 50%;
         z-index: 1000;
         display: none;
       }
       
       .morse-canvas {
         position: fixed;
         top: 50%;
         left: 0;
         width: 100%;
         height: 4px;
         transform: translateY(-50%);
         z-index: 1000;
         pointer-events: none;
       }
    </style>
</head>
<body>
    <code><pre>[ SPACE ] beep</pre></code>
    <div class="center-circle" id="centerCircle"></div>

    <div class="user-list" id="userList">
      <!-- User list will be populated here -->
    </div>

    <script>
       // No mode logic needed - all effects are always active
       
       // WebSocket connection
       let websocket = null
       let websocketConnected = false

       // User management
       let currentUserId = null
       let connectedUsers = []
       let userMorseStates = {} // Track morse state for each user
       let userMorseTimeouts = {} // Track timeouts for morse bars
       let userFrequencies = {} // Track audio frequency for each user
       
       // Initialize WebSocket connection
       function initWebSocket() {
         try {
           websocket = new WebSocket('wss://morwse-production.up.railway.app/ws')
           
           websocket.onopen = function(event) {
             websocketConnected = true
             console.log('WebSocket connected')
           }
           
           websocket.onclose = function(event) {
             websocketConnected = false
             console.log('WebSocket disconnected')
           }
           
           websocket.onerror = function(error) {
             websocketConnected = false
             console.log('WebSocket error:', error)
           }
           
           websocket.onmessage = function(event) {
             console.log('WebSocket message received:', event.data)

             // Handle JSON messages
             if (typeof event.data === 'string') {
               try {
                 const message = JSON.parse(event.data)
                 handleWebSocketMessage(message)
               } catch (e) {
                 console.error('Failed to parse JSON message:', e)
               }
             } else {
               console.error('Received unexpected message type:', typeof event.data)
             }
           }
         } catch (error) {
           console.log('Failed to create WebSocket connection:', error)
         }
       }

       // Handle different types of WebSocket messages
       function handleWebSocketMessage(message) {
         console.log('Handling message:', message)

         switch (message.type) {
           case 'user_info':
             currentUserId = message.user_id
             console.log('Set current user ID:', currentUserId)
             break

           case 'user_list':
             connectedUsers = message.users
             console.log('Updated user list:', connectedUsers)
             updateUserListDisplay()
             break

           case 'space_event':
             console.log('Space event from:', message.user_id, 'value:', message.value)
             if (message.value === 1) {
               handleRemoteSpacePress(message.user_id)
             } else if (message.value === 0) {
               handleRemoteSpaceRelease(message.user_id)
             }
             break

           default:
             console.log('Unknown message type:', message.type)
         }
       }

       // Update the user list display
       function updateUserListDisplay() {
         const userListElement = document.getElementById('userList')
         userListElement.innerHTML = ''

         // Clear existing canvases
         Object.values(userCanvases).forEach(({ canvas }) => {
           if (canvas.parentNode) {
             canvas.parentNode.removeChild(canvas)
           }
         })
         userCanvases = {}
         userMorseSegments = {}
         userDrawingStates = {}

         // Sort users: current user first, then others
         const sortedUsers = [...connectedUsers].sort((a, b) => {
           if (a === currentUserId) return -1
           if (b === currentUserId) return 1
           return 0
         })

         sortedUsers.forEach((userId, index) => {
           const userItem = document.createElement('div')
           userItem.className = `user-item ${userId === currentUserId ? 'current-user' : ''}`
           userItem.id = `user-${userId}`

           const userName = document.createElement('div')
           userName.className = 'user-name'
           userName.textContent = userId === currentUserId ? ` (Me)${userId}` : userId

           userItem.appendChild(userName)
           userListElement.appendChild(userItem)

           // Create canvas for this user
           createUserMorseCanvas(userId, index)

           // Initialize morse state for this user
           userMorseStates[userId] = false
           userMorseSegments[userId] = []
           userDrawingStates[userId] = false
         })
       }

       // Create a morse canvas for a specific user
       function createUserMorseCanvas(userId, index) {
         const canvas = document.createElement('canvas')
         canvas.className = 'user-morse-canvas'
         canvas.id = `morse-canvas-${userId}`

         // Set canvas size - width should match the CSS calc()
         canvas.width = window.innerWidth - 140
         canvas.height = 4

         // Append to the user item
         const userItem = document.getElementById(`user-${userId}`)
         userItem.appendChild(canvas)

         const ctx = canvas.getContext('2d')

         // Set drawing style based on user
         if (userId === currentUserId) {
           ctx.fillStyle = '#ffffff' // White for current user
         } else {
           ctx.fillStyle = '#00ff00' // Green for other users
         }

         userCanvases[userId] = { canvas, ctx }
       }

       // Update morse visualization for a specific user
       function updateUserMorse(userId, isPressed) {
         if (!userCanvases[userId]) return

         if (isPressed) {
           userMorseStates[userId] = true
           userDrawingStates[userId] = true

           // Create a new segment at the right side
           const newSegment = {
             x: window.innerWidth - 20,
             width: 2,
             isActive: true,
             userId: userId
           }

           userMorseSegments[userId].push(newSegment)
           startGlobalMorseAnimation()
         } else {
           userMorseStates[userId] = false
           userDrawingStates[userId] = false
         }
       }

       // Global animation loop for all users
       function startGlobalMorseAnimation() {
         if (globalAnimationId) return // Already running

         function animate() {
           let hasActiveSegments = false

           // Animate all users
           Object.keys(userCanvases).forEach(userId => {
             const { canvas, ctx } = userCanvases[userId]
             const segments = userMorseSegments[userId]

             // Clear canvas
             ctx.clearRect(0, 0, canvas.width, canvas.height)

             // Move all segments left and draw them
             for (let i = segments.length - 1; i >= 0; i--) {
               const segment = segments[i]
               segment.x -= 2 // Move 2px left per frame

               // Remove segments that are completely off screen
               if (segment.x + segment.width < 0) {
                 segments.splice(i, 1)
                 continue
               }

               // Draw the segment
               ctx.fillRect(segment.x, 1, segment.width, 2)
               hasActiveSegments = true
             }

             // If we're currently drawing a line, extend it
             if (userDrawingStates[userId]) {
               const currentSegment = segments[segments.length - 1]
               if (currentSegment) {
                 currentSegment.width += 1
                 // Don't let it go off the right edge
                 if (currentSegment.x + currentSegment.width > window.innerWidth) {
                   currentSegment.width = window.innerWidth - currentSegment.x
                 }
               }
               hasActiveSegments = true
             }
           })

           // Continue animation if any user has segments or is drawing
           if (hasActiveSegments || Object.values(userDrawingStates).some(state => state)) {
             globalAnimationId = requestAnimationFrame(animate)
           } else {
             globalAnimationId = null
           }
         }

         globalAnimationId = requestAnimationFrame(animate)
       }

       // Send WebSocket message as binary boolean
       function sendWebSocketMessage(value) {
         console.log('Attempting to send WebSocket message:', value, 'Connected:', websocketConnected, 'ReadyState:', websocket?.readyState)
         if (websocketConnected && websocket && websocket.readyState === WebSocket.OPEN) {
           const buffer = new Uint8Array([value])
           websocket.send(buffer)
           console.log('WebSocket message sent successfully:', value)
         } else {
           console.log('WebSocket not ready to send. Connected:', websocketConnected, 'ReadyState:', websocket?.readyState)
         }
       }
       
       // Web Audio API setup
       let audioContext = null
       let oscillator = null
       let gainNode = null
       
       // User morse code visualizer setup
       let userCanvases = {} // Per-user canvases
       let userMorseSegments = {} // Per-user morse segments
       let userDrawingStates = {} // Per-user drawing states
       let globalAnimationId = null // Single animation loop for all users

       // Generate unique frequency for a user based on their username
       function getUserFrequency(userId) {
         if (userFrequencies[userId]) {
           return userFrequencies[userId]
         }

         // Simple hash function to convert string to number
         let hash = 0
         for (let i = 0; i < userId.length; i++) {
           const char = userId.charCodeAt(i)
           hash = ((hash << 5) - hash) + char
           hash = hash & hash // Convert to 32bit integer
         }

         // Convert hash to frequency between 220Hz and 880Hz
         const frequency = 220 + (Math.abs(hash) % 661) // 661 = 880 - 220 + 1
         userFrequencies[userId] = frequency

         console.log(`Generated frequency for ${userId}: ${frequency}Hz`)
         return frequency
       }
       
       // Initialize WebSocket on page load
       document.addEventListener('DOMContentLoaded', function() {
         initWebSocket()
       })
       
       // Initialize audio context (will be created on first user interaction)
       function initAudioContext() {
         if (!audioContext) {
           audioContext = new (window.AudioContext || window.webkitAudioContext)()
           gainNode = audioContext.createGain()
           gainNode.connect(audioContext.destination)
         }
       }
       
       
       // Reusable functions for mode behaviors
       function startBackgroundColor() {
         document.body.style.backgroundColor = '#006600'
       }
       
       function stopBackgroundColor() {
         document.body.style.backgroundColor = ''
       }
       
       function startAudio(userId = currentUserId) {
         if (!oscillator) {
           initAudioContext()
           if (audioContext.state === 'suspended') {
             audioContext.resume()
           }

           // Reset gain to full volume
           gainNode.gain.setValueAtTime(0.3, audioContext.currentTime)

           oscillator = audioContext.createOscillator()
           oscillator.type = 'sine'
           const frequency = getUserFrequency(userId)
           oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime)
           oscillator.connect(gainNode)
           oscillator.start()
         }
       }
       
       function stopAudio() {
         if (oscillator) {
           try {
             // Quick volume fade-out to prevent clicking
             gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime)
             gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.01) // 10ms fade
             
             // Stop oscillator after fade completes
             setTimeout(() => {
               if (oscillator) {
                 oscillator.stop()
                 oscillator.disconnect()
                 oscillator = null
               }
             }, 15) // Slightly longer than fade duration
           } catch (e) {
             // Oscillator might already be stopped
             oscillator = null
           }
         }
       }
       
       
       // Remote user visualization functions
       function handleRemoteSpacePress(userId) {
         console.log('Remote space press from:', userId)

         // Update user's morse visualization
         updateUserMorse(userId, true)

         // Audio effects for remote users (no background color change)
         if (!oscillator) {
           initAudioContext()
           if (audioContext.state === 'suspended') {
             audioContext.resume()
           }

           gainNode.gain.setValueAtTime(0.2, audioContext.currentTime)

           oscillator = audioContext.createOscillator()
           oscillator.type = 'sine'
           const frequency = getUserFrequency(userId)
           oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime)
           oscillator.connect(gainNode)
           oscillator.start()
         }
       }

       function handleRemoteSpaceRelease(userId) {
         console.log('Remote space release from:', userId)

         // Update user's morse visualization
         updateUserMorse(userId, false)

         // Stop remote audio effects
         if (oscillator) {
           try {
             gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime)
             gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.01)

             setTimeout(() => {
               if (oscillator) {
                 oscillator.stop()
                 oscillator.disconnect()
                 oscillator = null
               }
             }, 15)
           } catch (e) {
             oscillator = null
           }
         }
       }


       // No mode switching needed
       

      const SPACE = 'Space'

      // Space bar behavior based on current mode
      document.addEventListener('keydown', function (event) {
        if (event.code === SPACE) {
          event.preventDefault() // Prevent default space bar behavior (page scrolling)
          handleSpacePress()
        }
      })

      document.addEventListener('keyup', function (event) {
        if (event.code === SPACE) {
          handleSpaceRelease()
        }
      })

       function handleSpacePress() {
         // Send WebSocket message for space press
         sendWebSocketMessage(1)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, true)
         }

         // Effects: background + audio
         startBackgroundColor()
         startAudio()
       }

       function handleSpaceRelease() {
         // Send WebSocket message for space release
         sendWebSocketMessage(0)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, false)
         }

         // Stop all effects
         stopBackgroundColor()
         stopAudio()
       }
    </script>
</body>
</html>
