<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>-- --- .-. .-- ... .</title>
    <style>
      body {
        background-color: #1a1a1a;
        color: #ffffff;
        font-family: 'Courier New', monospace;
        margin: 0;
        padding: 1rem;
      }

      pre {
        text-align: center;
        margin: 0;
        color: #707070;
      }

      .user-list {
        position: fixed;
        top: 0;
        right: 1rem;
        z-index: 1001;
        padding-top: 1rem;
      }

      .user-item {
        align-items: center;
        margin-bottom: 0.2rem;
        font-size: 14px;
        font-family: 'Courier New', monospace;
        cursor: pointer;
      }

      .user-item.current-user {
        cursor: default;
      }

      .user-item:last-child {
        margin-bottom: 0;
      }

      .user-item:hover:not(.current-user) .user-name {
        opacity: 0.7;
      }

      .user-name {
        color: #00ff00;
        min-width: 120px;
        text-align: right;
      }

      .current-user .user-name {
        font-weight: bold;
        color: #ffffff;
      }

      .user-item.muted .user-name {
        color: #555555;
        text-decoration: line-through;
      }

      .user-morse-canvas {
        position: absolute;
        right: 100%;
        width: calc(100vw - 140px);
        height: 4px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 999;
        pointer-events: none;
        margin-right: 10px;
      }

      .user-decoded-text {
        position: fixed;
        left: 10px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        white-space: nowrap;
        pointer-events: none;
        z-index: 998;
        transition: opacity 0.5s ease-out;
      }

      .current-user .user-decoded-text {
        color: #ffffff;
      }

      .user-item:not(.current-user) .user-decoded-text {
        color: #00ff00;
      }

      .user-item {
        position: relative;
      }
       
       .morse-canvas {
         position: fixed;
         top: 50%;
         left: 0;
         width: 100%;
         height: 4px;
         transform: translateY(-50%);
         z-index: 1000;
         pointer-events: none;
       }

       .morse-input-container {
         position: fixed;
         bottom: 0;
         left: 0;
         width: 100%;
         background-color: #2a2a2a;
         border-top: 2px solid #00ff00;
         padding: 1rem;
         z-index: 2000;
         display: none;
       }

       .morse-input-container.active {
         display: block;
       }

       .morse-input {
         width: 100%;
         background-color: #1a1a1a;
         color: #ffffff;
         border: 1px solid #00ff00;
         padding: 0.5rem;
         font-family: 'Courier New', monospace;
         font-size: 14px;
         outline: none;
       }

       .morse-input::placeholder {
         color: #808080;
       }

       .morse-input-hint {
         color: #808080;
         font-size: 12px;
         margin-top: 0.5rem;
       }
    </style>
</head>
<body>
    <code><pre>
[ SPACE ] beep
[ . ] dit
[ - ] dah
[ i ] input text as morse



-----------------------------------------------------------
| A             .-                  U             ..-     |
| B             -...                V             ...-    |
| C             -.-.                W             .--     |
| D             -..                 X             -..-    |
| E             .                   Y             -.--    |
| F             ..-.                Z             --..    |
| G             --.                 1             .----   |
| H             ....                2             ..---   |
| I             ..                  3             ...--   |
| J             .---                4             ....-   |
| K             -.-                 5             .....   |
| L             .-..                6             -....   |
| M             --                  7             --...   |
| N             -.                  8             ---..   |
| O             ---                 9             ----.   |
| P             .--.                0             -----   |
| Q             --.-                .             .-.-.-  |
| R             .-.                 ,             --..--  |
| S             ...                 ?             ..--..  |
| T             -                   /             -..-.   |
-----------------------------------------------------------
    </pre></code>

    <div class="user-list" id="userList">
      <!-- User list will be populated here -->
    </div>

    <div class="morse-input-container" id="morseInputContainer">
      <input type="text" class="morse-input" id="morseInput" placeholder="Type message to send as morse code..." />
      <div class="morse-input-hint">Press Enter to send, Esc to close</div>
    </div>

    <script>
       // No mode logic needed - all effects are always active
       
       // WebSocket connection
       let websocket = null
       let websocketConnected = false

       // User management
       let currentUserId = null
       let connectedUsers = []
       let userMorseStates = {} // Track morse state for each user
       let userMorseTimeouts = {} // Track timeouts for morse bars
       let userFrequencies = {} // Track audio frequency for each user
       let mutedUsers = new Set() // Track muted users
       
       // Initialize WebSocket connection
       function initWebSocket() {
         try {
           websocket = new WebSocket('wss://morwse-production.up.railway.app/ws')
           
           websocket.onopen = function(event) {
             websocketConnected = true
             console.log('WebSocket connected')
           }
           
           websocket.onclose = function(event) {
             websocketConnected = false
             console.log('WebSocket disconnected')
           }
           
           websocket.onerror = function(error) {
             websocketConnected = false
             console.log('WebSocket error:', error)
           }
           
           websocket.onmessage = function(event) {
             console.log('WebSocket message received:', event.data)

             // Handle JSON messages
             if (typeof event.data === 'string') {
               try {
                 const message = JSON.parse(event.data)
                 handleWebSocketMessage(message)
               } catch (e) {
                 console.error('Failed to parse JSON message:', e)
               }
             } else {
               console.error('Received unexpected message type:', typeof event.data)
             }
           }
         } catch (error) {
           console.log('Failed to create WebSocket connection:', error)
         }
       }

       // Handle different types of WebSocket messages
       function handleWebSocketMessage(message) {
         console.log('Handling message:', message)

         switch (message.type) {
           case 'user_info':
             currentUserId = message.user_id
             console.log('Set current user ID:', currentUserId)
             break

           case 'user_list':
             connectedUsers = message.users
             console.log('Updated user list:', connectedUsers)
             updateUserListDisplay()
             break

           case 'space_event':
             console.log('Space event from:', message.user_id, 'value:', message.value)
             if (message.value === 1) {
               handleRemoteSpacePress(message.user_id)
             } else if (message.value === 0) {
               handleRemoteSpaceRelease(message.user_id)
             }
             break

           default:
             console.log('Unknown message type:', message.type)
         }
       }

       // Toggle mute for a user
       function toggleUserMute(userId) {
         if (mutedUsers.has(userId)) {
           mutedUsers.delete(userId)
           console.log(`Unmuted user: ${userId}`)
         } else {
           mutedUsers.add(userId)
           console.log(`Muted user: ${userId}`)
           // Stop any currently playing audio for this user
           stopAudio(userId)
           // Clear any existing morse segments for this user
           if (userMorseSegments[userId]) {
             userMorseSegments[userId] = []
           }
           // Stop any active drawing state
           userDrawingStates[userId] = false
           userMorseStates[userId] = false
         }
         // Update the display to reflect muted state
         updateUserListDisplay()
       }

       // Update the user list display
       function updateUserListDisplay() {
         const userListElement = document.getElementById('userList')
         userListElement.innerHTML = ''

         // Clear existing canvases
         Object.values(userCanvases).forEach(({ canvas }) => {
           if (canvas.parentNode) {
             canvas.parentNode.removeChild(canvas)
           }
         })
         userCanvases = {}
         userMorseSegments = {}
         userDrawingStates = {}

         // Sort users: current user first, then others
         const sortedUsers = [...connectedUsers].sort((a, b) => {
           if (a === currentUserId) return -1
           if (b === currentUserId) return 1
           return 0
         })

         sortedUsers.forEach((userId, index) => {
           const userItem = document.createElement('div')
           const isMuted = mutedUsers.has(userId)
           userItem.className = `user-item ${userId === currentUserId ? 'current-user' : ''} ${isMuted ? 'muted' : ''}`
           userItem.id = `user-${userId}`

           const userName = document.createElement('div')
           userName.className = 'user-name'
           userName.textContent = userId === currentUserId ? ` (Me)${userId}` : userId

           userItem.appendChild(userName)
           userListElement.appendChild(userItem)

           // Add click handler to toggle mute (except for current user)
           if (userId !== currentUserId) {
             userItem.addEventListener('click', (event) => {
               event.stopPropagation()
               event.preventDefault()
               toggleUserMute(userId)
             })
           }

           // Create canvas for this user
           createUserMorseCanvas(userId, index)

           // Create decoded text display for this user
           createUserDecodedText(userId, index)

           // Initialize morse state for this user
           userMorseStates[userId] = false
           userMorseSegments[userId] = []
           userDrawingStates[userId] = false
           userMorsePatterns[userId] = ''
           userLastSignalTime[userId] = 0
           userSignalStartTime[userId] = 0
           userDecodedText[userId] = ''
         })
       }

       // Create a morse canvas for a specific user
       function createUserMorseCanvas(userId, index) {
         const canvas = document.createElement('canvas')
         canvas.className = 'user-morse-canvas'
         canvas.id = `morse-canvas-${userId}`

         // Set canvas size - width should match the CSS calc()
         canvas.width = window.innerWidth - 140
         canvas.height = 4

         // Append to the user item
         const userItem = document.getElementById(`user-${userId}`)
         userItem.appendChild(canvas)

         const ctx = canvas.getContext('2d')

         // Set drawing style based on user
         if (userId === currentUserId) {
           ctx.fillStyle = '#ffffff' // White for current user
         } else {
           ctx.fillStyle = '#00ff00' // Green for other users
         }

         userCanvases[userId] = { canvas, ctx }
       }

       // Create decoded text display for a specific user
       function createUserDecodedText(userId, index) {
         const textDiv = document.createElement('div')
         textDiv.className = 'user-decoded-text'
         textDiv.id = `decoded-text-${userId}`

         // Position it at the same vertical level as the user's row
         const userItem = document.getElementById(`user-${userId}`)
         const rect = userItem.getBoundingClientRect()
         textDiv.style.top = `${rect.top + window.scrollY}px`

         // Append to body so it can be positioned on the left side
         document.body.appendChild(textDiv)
       }

       // Update decoded text display for a user
       function updateDecodedTextDisplay(userId, text) {
         const textDiv = document.getElementById(`decoded-text-${userId}`)
         if (textDiv) {
           console.log(`${userId}: Updating display with "${text}"`)
           textDiv.textContent = text
           textDiv.style.opacity = '1'
         } else {
           console.log(`${userId}: Text div not found!`)
         }
       }

       // Fade out decoded text after delay
       function fadeOutDecodedText(userId, delay = 3000) {
         setTimeout(() => {
           const textDiv = document.getElementById(`decoded-text-${userId}`)
           if (textDiv) {
             textDiv.style.opacity = '0'
             // Clear text after fade completes
             setTimeout(() => {
               if (textDiv && textDiv.style.opacity === '0') {
                 textDiv.textContent = ''
                 userDecodedText[userId] = ''
               }
             }, 500) // Match CSS transition duration
           }
         }, delay)
       }

       // Decode morse pattern and update display
       function decodeMorsePattern(userId) {
         const pattern = userMorsePatterns[userId]
         if (!pattern) {
           console.log(`${userId}: decodeMorsePattern called but pattern is empty`)
           return
         }

         console.log(`${userId}: ===== DECODING PATTERN "${pattern}" =====`)
         const letter = MORSE_TO_LETTER[pattern]
         if (letter) {
           console.log(`${userId}: ✓ Decoded to "${letter}"`)
           userDecodedText[userId] += letter
           console.log(`${userId}: Full decoded text: "${userDecodedText[userId]}"`)
           updateDecodedTextDisplay(userId, userDecodedText[userId])
           // Fade out after 3 seconds
           fadeOutDecodedText(userId, 3000)
         } else {
           console.log(`${userId}: ✗ Pattern "${pattern}" not recognized`)
           console.log(`${userId}: Available patterns:`, Object.keys(MORSE_TO_LETTER).slice(0, 10))
         }

         // Clear pattern for next letter
         console.log(`${userId}: Clearing pattern`)
         userMorsePatterns[userId] = ''
       }

       // Update morse visualization for a specific user
       function updateUserMorse(userId, isPressed) {
         if (!userCanvases[userId]) return

         // Don't draw for muted users (except current user)
         if (mutedUsers.has(userId) && userId !== currentUserId) return

         const now = Date.now()

         if (isPressed) {
           userMorseStates[userId] = true
           userDrawingStates[userId] = true
           userSignalStartTime[userId] = now

           // Cancel any pending timeout since a new signal is starting
           clearTimeout(userMorseTimeouts[userId])

           // Check gap since last signal to determine if this is a new letter or word
           if (userLastSignalTime[userId] && userMorsePatterns[userId]) {
             const gapDuration = now - userLastSignalTime[userId]
             console.log(`${userId}: Gap since last signal: ${gapDuration}ms`)

             // Gap of 7+ units (420ms+) = word space
             if (gapDuration >= DIT_UNIT * 6.5) {
               console.log(`${userId}: Word gap detected`)
               // Decode current pattern first
               if (userMorsePatterns[userId]) {
                 decodeMorsePattern(userId)
               }
               userDecodedText[userId] += ' '
               updateDecodedTextDisplay(userId, userDecodedText[userId])
             }
             // Gap of 3+ units (180ms+) = new letter, decode previous pattern
             else if (gapDuration >= DIT_UNIT * 2.5) {
               console.log(`${userId}: Letter gap detected (${gapDuration}ms), decoding pattern "${userMorsePatterns[userId]}"`)
               decodeMorsePattern(userId)
             }
           }

           // Create a new segment at the right side
           const newSegment = {
             x: window.innerWidth - 20,
             width: 2,
             isActive: true,
             userId: userId,
             startTime: now
           }

           userMorseSegments[userId].push(newSegment)
           startGlobalMorseAnimation()
         } else {
           userMorseStates[userId] = false
           userDrawingStates[userId] = false
           userLastSignalTime[userId] = now

           // Calculate signal duration to determine dit or dah
           const signalDuration = now - userSignalStartTime[userId]

           // Threshold: < 2 units (120ms) = dit, >= 2 units = dah
           if (signalDuration < DIT_UNIT * 2) {
             userMorsePatterns[userId] += '.'
             console.log(`${userId}: dit (${signalDuration}ms) - pattern: ${userMorsePatterns[userId]}`)
           } else {
             userMorsePatterns[userId] += '-'
             console.log(`${userId}: dah (${signalDuration}ms) - pattern: ${userMorsePatterns[userId]}`)
           }

           // Set timeout to decode pattern if no new signal comes
           // Wait 3 units (letter gap) before decoding
           clearTimeout(userMorseTimeouts[userId])
           userMorseTimeouts[userId] = setTimeout(() => {
             if (userMorsePatterns[userId]) {
               console.log(`${userId}: ⏰ TIMEOUT reached after ${DIT_UNIT * 3}ms, decoding pattern`)
               decodeMorsePattern(userId)
             }
           }, DIT_UNIT * 3) // 180ms = 3 dit units
         }
       }

       // Global animation loop for all users
       function startGlobalMorseAnimation() {
         if (globalAnimationId) return // Already running

         function animate() {
           let hasActiveSegments = false

           // Animate all users
           Object.keys(userCanvases).forEach(userId => {
             const { canvas, ctx } = userCanvases[userId]
             const segments = userMorseSegments[userId]

             // Clear canvas
             ctx.clearRect(0, 0, canvas.width, canvas.height)

             // Move all segments left and draw them
             for (let i = segments.length - 1; i >= 0; i--) {
               const segment = segments[i]
               segment.x -= 2 // Move 2px left per frame

               // Remove segments that are completely off screen
               if (segment.x + segment.width < 0) {
                 segments.splice(i, 1)
                 continue
               }

               // Draw the segment
               ctx.fillRect(segment.x, 1, segment.width, 2)
               hasActiveSegments = true
             }

             // If we're currently drawing a line, extend it
             if (userDrawingStates[userId]) {
               const currentSegment = segments[segments.length - 1]
               if (currentSegment) {
                 currentSegment.width += 1
                 // Don't let it go off the right edge
                 if (currentSegment.x + currentSegment.width > window.innerWidth) {
                   currentSegment.width = window.innerWidth - currentSegment.x
                 }
               }
               hasActiveSegments = true
             }
           })

           // Continue animation if any user has segments or is drawing
           if (hasActiveSegments || Object.values(userDrawingStates).some(state => state)) {
             globalAnimationId = requestAnimationFrame(animate)
           } else {
             globalAnimationId = null
           }
         }

         globalAnimationId = requestAnimationFrame(animate)
       }

       // Send WebSocket message as binary boolean
       function sendWebSocketMessage(value) {
         console.log('Attempting to send WebSocket message:', value, 'Connected:', websocketConnected, 'ReadyState:', websocket?.readyState)
         if (websocketConnected && websocket && websocket.readyState === WebSocket.OPEN) {
           const buffer = new Uint8Array([value])
           websocket.send(buffer)
           console.log('WebSocket message sent successfully:', value)
         } else {
           console.log('WebSocket not ready to send. Connected:', websocketConnected, 'ReadyState:', websocket?.readyState)
         }
       }
       
       // Web Audio API setup
       let audioContext = null
       let userOscillators = {} // Per-user oscillators
       let mainGainNode = null
       
       // User morse code visualizer setup
       let userCanvases = {} // Per-user canvases
       let userMorseSegments = {} // Per-user morse segments
       let userDrawingStates = {} // Per-user drawing states
       let globalAnimationId = null // Single animation loop for all users

       // Generate unique frequency for a user based on their username
       function getUserFrequency(userId) {
         if (userFrequencies[userId]) {
           return userFrequencies[userId]
         }

         // Simple hash function to convert string to number
         let hash = 0
         for (let i = 0; i < userId.length; i++) {
           const char = userId.charCodeAt(i)
           hash = ((hash << 5) - hash) + char
           hash = hash & hash // Convert to 32bit integer
         }

         // Convert hash to frequency between 220Hz and 880Hz
         const frequency = 220 + (Math.abs(hash) % 661) // 661 = 880 - 220 + 1
         userFrequencies[userId] = frequency

         console.log(`Generated frequency for ${userId}: ${frequency}Hz`)
         return frequency
       }
       
       // Initialize WebSocket on page load
       document.addEventListener('DOMContentLoaded', function() {
         initWebSocket()
       })
       
       // Initialize audio context (will be created on first user interaction)
       function initAudioContext() {
         if (!audioContext) {
           audioContext = new (window.AudioContext || window.webkitAudioContext)()
           mainGainNode = audioContext.createGain()
           mainGainNode.connect(audioContext.destination)
         }
       }
       
       
       // Reusable functions for mode behaviors
       function startBackgroundColor() {
         document.body.style.backgroundColor = '#006600'
       }
       
       function stopBackgroundColor() {
         document.body.style.backgroundColor = ''
       }
       
       function startAudio(userId = currentUserId) {
         // Don't play audio for muted users
         if (mutedUsers.has(userId)) {
           return
         }

         if (!userOscillators[userId]) {
           initAudioContext()
           if (audioContext.state === 'suspended') {
             audioContext.resume()
           }

           // Create individual gain node for this user
           const userGainNode = audioContext.createGain()
           const volume = userId === currentUserId ? 0.3 : 0.2
           userGainNode.gain.setValueAtTime(volume, audioContext.currentTime)
           userGainNode.connect(mainGainNode)

           // Create oscillator for this user
           const oscillator = audioContext.createOscillator()
           oscillator.type = 'sine'
           const frequency = getUserFrequency(userId)
           oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime)
           oscillator.connect(userGainNode)
           oscillator.start()

           // Store both oscillator and gain node
           userOscillators[userId] = { oscillator, gainNode: userGainNode }
         }
       }
       
       function stopAudio(userId = currentUserId) {
         const userAudio = userOscillators[userId]
         if (userAudio) {
           try {
             // Quick volume fade-out to prevent clicking
             userAudio.gainNode.gain.setValueAtTime(userAudio.gainNode.gain.value, audioContext.currentTime)
             userAudio.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.01) // 10ms fade

             // Stop oscillator after fade completes
             setTimeout(() => {
               if (userOscillators[userId]) {
                 userAudio.oscillator.stop()
                 userAudio.oscillator.disconnect()
                 userAudio.gainNode.disconnect()
                 delete userOscillators[userId]
               }
             }, 15) // Slightly longer than fade duration
           } catch (e) {
             // Oscillator might already be stopped
             delete userOscillators[userId]
           }
         }
       }
       
       
       // Remote user visualization functions
       function handleRemoteSpacePress(userId) {
         console.log('Remote space press from:', userId)

         // Update user's morse visualization
         updateUserMorse(userId, true)

         // Audio effects for remote users (no background color change)
         startAudio(userId)
       }

       function handleRemoteSpaceRelease(userId) {
         console.log('Remote space release from:', userId)

         // Update user's morse visualization
         updateUserMorse(userId, false)

         // Stop remote audio effects
         stopAudio(userId)
       }


       // No mode switching needed
       

      const SPACE = 'Space'
      const DIT_KEY = 'Period' // . key
      const DAH_KEY = 'Minus' // - key
      const INPUT_KEY = 'KeyI' // i key

      // Morse code timing (based on 1 dit unit = 60ms)
      const DIT_UNIT = 60 // Base time unit
      const DIT_DURATION = DIT_UNIT // 1 unit
      const DAH_DURATION = DIT_UNIT * 3 // 3 units (180ms)
      const INTER_SYMBOL_GAP = DIT_UNIT // 1 unit gap within letter (60ms)
      const LETTER_GAP = DIT_UNIT * 3 // 3 units between letters (180ms)
      const WORD_GAP = DIT_UNIT * 7 // 7 units between words (420ms)

      let ditTimeout = null
      let dahTimeout = null
      let ditActive = false
      let dahActive = false
      let morseInputActive = false
      let morseTransmitting = false

      // Morse code lookup table
      const MORSE_CODE = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
        'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--',
        '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..',
        '9': '----.', '0': '-----', '.': '.-.-.-', ',': '--..--', '?': '..--..',
        '/': '-..-.', ' ': ' '
      }

      // Reverse morse code lookup (morse to letter)
      const MORSE_TO_LETTER = {}
      Object.keys(MORSE_CODE).forEach(letter => {
        const morse = MORSE_CODE[letter]
        if (morse !== ' ') {
          MORSE_TO_LETTER[morse] = letter
        }
      })

      // Morse decoder state per user
      let userMorsePatterns = {} // Current morse pattern being built
      let userLastSignalTime = {} // Last signal timestamp
      let userSignalStartTime = {} // When signal started (for duration)
      let userDecodedText = {} // Decoded text for each user

      // Space bar behavior based on current mode
      document.addEventListener('keydown', function (event) {
        // Handle input mode toggle - only open with 'i', not close
        if (event.code === INPUT_KEY && !event.repeat && !morseTransmitting && !morseInputActive) {
          event.preventDefault()
          toggleMorseInput()
          return
        }

        // If input is active, don't handle other keys (except within input field)
        if (morseInputActive) {
          return
        }

        if (event.code === SPACE && !event.repeat) {
          event.preventDefault() // Prevent default space bar behavior (page scrolling)
          handleSpacePress()
        } else if (event.code === DIT_KEY && !event.repeat && !ditActive) {
          event.preventDefault()
          handleDitPress()
        } else if (event.code === DAH_KEY && !event.repeat && !dahActive) {
          event.preventDefault()
          handleDahPress()
        }
      })

      document.addEventListener('keyup', function (event) {
        if (morseInputActive) return

        if (event.code === SPACE) {
          handleSpaceRelease()
        }
      })

      // Mobile/Mouse support: allow clicking anywhere on screen
      let isMousePressed = false

      // Mouse events for desktop
      document.addEventListener('mousedown', function(event) {
        // Don't trigger beep if clicking on user items or input
        if (event.target.closest('.user-item') || event.target.closest('.morse-input-container')) {
          return
        }
        if (isMousePressed) return // Prevent double-press
        isMousePressed = true
        event.preventDefault()
        handleSpacePress()
      })

      document.addEventListener('mouseup', function(event) {
        if (!isMousePressed) return
        isMousePressed = false
        event.preventDefault()
        handleSpaceRelease()
      })

      // Touch events for mobile
      document.addEventListener('touchstart', function(event) {
        // Don't trigger beep if touching user items or input
        if (event.target.closest('.user-item') || event.target.closest('.morse-input-container')) {
          return
        }
        event.preventDefault()
        handleSpacePress()
      })

      document.addEventListener('touchend', function(event) {
        // Don't trigger beep if touching user items or input
        if (event.target.closest('.user-item') || event.target.closest('.morse-input-container')) {
          return
        }
        event.preventDefault()
        handleSpaceRelease()
      })

      document.addEventListener('touchcancel', function(event) {
        event.preventDefault()
        handleSpaceRelease()
      })

       function handleSpacePress() {
         // Send WebSocket message for space press
         sendWebSocketMessage(1)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, true)
         }

         // Effects: background + audio
         startBackgroundColor()
         startAudio(currentUserId)
       }

       function handleSpaceRelease() {
         // Send WebSocket message for space release
         sendWebSocketMessage(0)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, false)
         }

         // Stop all effects
         stopBackgroundColor()
         stopAudio(currentUserId)
       }

      // Helper function to perform a morse symbol with given duration
      function performMorseSymbol(duration) {
        return new Promise((resolve) => {
          // Send WebSocket message for start
          sendWebSocketMessage(1)

          // Update current user's morse visualization
          if (currentUserId) {
            updateUserMorse(currentUserId, true)
          }

          // Effects: background + audio
          startBackgroundColor()
          startAudio(currentUserId)

          // Auto-release after duration
          setTimeout(() => {
            sendWebSocketMessage(0)
            if (currentUserId) {
              updateUserMorse(currentUserId, false)
            }
            stopBackgroundColor()
            stopAudio(currentUserId)
            resolve()
          }, duration)
        })
      }

      function handleDitPress() {
        // Fire and forget - ignore if already active
        if (ditActive) return

        ditActive = true
        performMorseSymbol(DIT_DURATION).then(() => {
          ditTimeout = null
          ditActive = false
        })
      }

      function handleDahPress() {
        // Fire and forget - ignore if already active
        if (dahActive) return

        dahActive = true
        performMorseSymbol(DAH_DURATION).then(() => {
          dahTimeout = null
          dahActive = false
        })
      }

       // Toggle morse code input
       function toggleMorseInput() {
         const container = document.getElementById('morseInputContainer')
         const input = document.getElementById('morseInput')

         morseInputActive = !morseInputActive

         if (morseInputActive) {
           container.classList.add('active')
           input.focus()
         } else {
           container.classList.remove('active')
           input.value = ''
         }
       }

       // Handle input field events
       document.addEventListener('DOMContentLoaded', function() {
         const input = document.getElementById('morseInput')

         input.addEventListener('keydown', function(event) {
           if (event.key === 'Enter') {
             event.preventDefault()
             const text = input.value.trim()
             if (text && !morseTransmitting) {
               transmitMorseCode(text)
             }
           } else if (event.key === 'Escape') {
             event.preventDefault()
             toggleMorseInput()
           }
         })
       })

      // Convert text to morse and transmit
      async function transmitMorseCode(text) {
        if (morseTransmitting) return

        morseTransmitting = true
        try {
          const upperText = text.toUpperCase()

          // Close input
          toggleMorseInput()

          for (let i = 0; i < upperText.length; i++) {
            const char = upperText[i]
            const morseSymbols = MORSE_CODE[char]

            if (!morseSymbols) continue // Skip unknown characters

            if (morseSymbols === ' ') {
              // Word gap (already includes letter gap from previous letter)
              await sleep(WORD_GAP - LETTER_GAP)
            } else {
              // Transmit each dit or dah
              for (let j = 0; j < morseSymbols.length; j++) {
                const symbol = morseSymbols[j]

                if (symbol === '.') {
                  await transmitDit()
                } else if (symbol === '-') {
                  await transmitDah()
                }

                // Gap between symbols within the same letter
                if (j < morseSymbols.length - 1) {
                  await sleep(INTER_SYMBOL_GAP)
                }
              }

              // Gap between letters
              if (i < upperText.length - 1 && upperText[i + 1] !== ' ') {
                await sleep(LETTER_GAP)
              }
            }
          }
        } finally {
          morseTransmitting = false
        }
      }

      // Transmit a dit
      function transmitDit() {
        return performMorseSymbol(DIT_DURATION)
      }

      // Transmit a dah
      function transmitDah() {
        return performMorseSymbol(DAH_DURATION)
      }

       // Sleep utility
       function sleep(ms) {
         return new Promise(resolve => setTimeout(resolve, ms))
       }
    </script>
</body>
</html>
