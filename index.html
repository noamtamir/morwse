<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>-- --- .-. .-- ... .</title>
    <style>
      body {
        background-color: #1a1a1a;
        color: #ffffff;
        font-family: 'Courier New', monospace;
        margin: 0;
        padding: 1rem;
      }

      pre {
        text-align: center;
        margin: 0;
        color: #707070;
      }

      .user-list {
        position: fixed;
        top: 0;
        right: 1rem;
        z-index: 1001;
        padding-top: 1rem;
      }

      .user-item {
        align-items: center;
        margin-bottom: 0.2rem;
        font-size: 14px;
        font-family: 'Courier New', monospace;
      }

      .user-item:last-child {
        margin-bottom: 0;
      }

      .user-name {
        color: #00ff00;
        min-width: 120px;
        text-align: right;
      }

      .current-user .user-name {
        font-weight: bold;
        color: #ffffff;
      }

      .user-morse-canvas {
        position: absolute;
        right: 100%;
        width: calc(100vw - 140px);
        height: 4px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 999;
        pointer-events: none;
        margin-right: 10px;
      }

      .user-item {
        position: relative;
      }
       
       .morse-canvas {
         position: fixed;
         top: 50%;
         left: 0;
         width: 100%;
         height: 4px;
         transform: translateY(-50%);
         z-index: 1000;
         pointer-events: none;
       }

       .morse-input-container {
         position: fixed;
         bottom: 0;
         left: 0;
         width: 100%;
         background-color: #2a2a2a;
         border-top: 2px solid #00ff00;
         padding: 1rem;
         z-index: 2000;
         display: none;
       }

       .morse-input-container.active {
         display: block;
       }

       .morse-input {
         width: 100%;
         background-color: #1a1a1a;
         color: #ffffff;
         border: 1px solid #00ff00;
         padding: 0.5rem;
         font-family: 'Courier New', monospace;
         font-size: 14px;
         outline: none;
       }

       .morse-input::placeholder {
         color: #808080;
       }

       .morse-input-hint {
         color: #808080;
         font-size: 12px;
         margin-top: 0.5rem;
       }
    </style>
</head>
<body>
    <code><pre>
[ SPACE ] beep
[ . ] dit
[ - ] dah
[ i ] input text as morse



-----------------------------------------------------------
| A             .-                  U             ..-     |
| B             -...                V             ...-    |
| C             -.-.                W             .--     |
| D             -..                 X             -..-    |
| E             .                   Y             -.--    |
| F             ..-.                Z             --..    |
| G             --.                 1             .----   |
| H             ....                2             ..---   |
| I             ..                  3             ...--   |
| J             .---                4             ....-   |
| K             -.-                 5             .....   |
| L             .-..                6             -....   |
| M             --                  7             --...   |
| N             -.                  8             ---..   |
| O             ---                 9             ----.   |
| P             .--.                0             -----   |
| Q             --.-                .             .-.-.-  |
| R             .-.                 ,             --..--  |
| S             ...                 ?             ..--..  |
| T             -                   /             -..-.   |
-----------------------------------------------------------
    </pre></code>

    <div class="user-list" id="userList">
      <!-- User list will be populated here -->
    </div>

    <div class="morse-input-container" id="morseInputContainer">
      <input type="text" class="morse-input" id="morseInput" placeholder="Type message to send as morse code..." />
      <div class="morse-input-hint">Press Enter to send, Esc to close</div>
    </div>

    <script>
       // No mode logic needed - all effects are always active
       
       // WebSocket connection
       let websocket = null
       let websocketConnected = false

       // User management
       let currentUserId = null
       let connectedUsers = []
       let userMorseStates = {} // Track morse state for each user
       let userMorseTimeouts = {} // Track timeouts for morse bars
       let userFrequencies = {} // Track audio frequency for each user
       
       // Initialize WebSocket connection
       function initWebSocket() {
         try {
           websocket = new WebSocket('wss://morwse-production.up.railway.app/ws')
           
           websocket.onopen = function(event) {
             websocketConnected = true
             console.log('WebSocket connected')
           }
           
           websocket.onclose = function(event) {
             websocketConnected = false
             console.log('WebSocket disconnected')
           }
           
           websocket.onerror = function(error) {
             websocketConnected = false
             console.log('WebSocket error:', error)
           }
           
           websocket.onmessage = function(event) {
             console.log('WebSocket message received:', event.data)

             // Handle JSON messages
             if (typeof event.data === 'string') {
               try {
                 const message = JSON.parse(event.data)
                 handleWebSocketMessage(message)
               } catch (e) {
                 console.error('Failed to parse JSON message:', e)
               }
             } else {
               console.error('Received unexpected message type:', typeof event.data)
             }
           }
         } catch (error) {
           console.log('Failed to create WebSocket connection:', error)
         }
       }

       // Handle different types of WebSocket messages
       function handleWebSocketMessage(message) {
         console.log('Handling message:', message)

         switch (message.type) {
           case 'user_info':
             currentUserId = message.user_id
             console.log('Set current user ID:', currentUserId)
             break

           case 'user_list':
             connectedUsers = message.users
             console.log('Updated user list:', connectedUsers)
             updateUserListDisplay()
             break

           case 'space_event':
             console.log('Space event from:', message.user_id, 'value:', message.value)
             if (message.value === 1) {
               handleRemoteSpacePress(message.user_id)
             } else if (message.value === 0) {
               handleRemoteSpaceRelease(message.user_id)
             }
             break

           default:
             console.log('Unknown message type:', message.type)
         }
       }

       // Update the user list display
       function updateUserListDisplay() {
         const userListElement = document.getElementById('userList')
         userListElement.innerHTML = ''

         // Clear existing canvases
         Object.values(userCanvases).forEach(({ canvas }) => {
           if (canvas.parentNode) {
             canvas.parentNode.removeChild(canvas)
           }
         })
         userCanvases = {}
         userMorseSegments = {}
         userDrawingStates = {}

         // Sort users: current user first, then others
         const sortedUsers = [...connectedUsers].sort((a, b) => {
           if (a === currentUserId) return -1
           if (b === currentUserId) return 1
           return 0
         })

         sortedUsers.forEach((userId, index) => {
           const userItem = document.createElement('div')
           userItem.className = `user-item ${userId === currentUserId ? 'current-user' : ''}`
           userItem.id = `user-${userId}`

           const userName = document.createElement('div')
           userName.className = 'user-name'
           userName.textContent = userId === currentUserId ? ` (Me)${userId}` : userId

           userItem.appendChild(userName)
           userListElement.appendChild(userItem)

           // Create canvas for this user
           createUserMorseCanvas(userId, index)

           // Initialize morse state for this user
           userMorseStates[userId] = false
           userMorseSegments[userId] = []
           userDrawingStates[userId] = false
         })
       }

       // Create a morse canvas for a specific user
       function createUserMorseCanvas(userId, index) {
         const canvas = document.createElement('canvas')
         canvas.className = 'user-morse-canvas'
         canvas.id = `morse-canvas-${userId}`

         // Set canvas size - width should match the CSS calc()
         canvas.width = window.innerWidth - 140
         canvas.height = 4

         // Append to the user item
         const userItem = document.getElementById(`user-${userId}`)
         userItem.appendChild(canvas)

         const ctx = canvas.getContext('2d')

         // Set drawing style based on user
         if (userId === currentUserId) {
           ctx.fillStyle = '#ffffff' // White for current user
         } else {
           ctx.fillStyle = '#00ff00' // Green for other users
         }

         userCanvases[userId] = { canvas, ctx }
       }

       // Update morse visualization for a specific user
       function updateUserMorse(userId, isPressed) {
         if (!userCanvases[userId]) return

         if (isPressed) {
           userMorseStates[userId] = true
           userDrawingStates[userId] = true

           // Create a new segment at the right side
           const newSegment = {
             x: window.innerWidth - 20,
             width: 2,
             isActive: true,
             userId: userId
           }

           userMorseSegments[userId].push(newSegment)
           startGlobalMorseAnimation()
         } else {
           userMorseStates[userId] = false
           userDrawingStates[userId] = false
         }
       }

       // Global animation loop for all users
       function startGlobalMorseAnimation() {
         if (globalAnimationId) return // Already running

         function animate() {
           let hasActiveSegments = false

           // Animate all users
           Object.keys(userCanvases).forEach(userId => {
             const { canvas, ctx } = userCanvases[userId]
             const segments = userMorseSegments[userId]

             // Clear canvas
             ctx.clearRect(0, 0, canvas.width, canvas.height)

             // Move all segments left and draw them
             for (let i = segments.length - 1; i >= 0; i--) {
               const segment = segments[i]
               segment.x -= 2 // Move 2px left per frame

               // Remove segments that are completely off screen
               if (segment.x + segment.width < 0) {
                 segments.splice(i, 1)
                 continue
               }

               // Draw the segment
               ctx.fillRect(segment.x, 1, segment.width, 2)
               hasActiveSegments = true
             }

             // If we're currently drawing a line, extend it
             if (userDrawingStates[userId]) {
               const currentSegment = segments[segments.length - 1]
               if (currentSegment) {
                 currentSegment.width += 1
                 // Don't let it go off the right edge
                 if (currentSegment.x + currentSegment.width > window.innerWidth) {
                   currentSegment.width = window.innerWidth - currentSegment.x
                 }
               }
               hasActiveSegments = true
             }
           })

           // Continue animation if any user has segments or is drawing
           if (hasActiveSegments || Object.values(userDrawingStates).some(state => state)) {
             globalAnimationId = requestAnimationFrame(animate)
           } else {
             globalAnimationId = null
           }
         }

         globalAnimationId = requestAnimationFrame(animate)
       }

       // Send WebSocket message as binary boolean
       function sendWebSocketMessage(value) {
         console.log('Attempting to send WebSocket message:', value, 'Connected:', websocketConnected, 'ReadyState:', websocket?.readyState)
         if (websocketConnected && websocket && websocket.readyState === WebSocket.OPEN) {
           const buffer = new Uint8Array([value])
           websocket.send(buffer)
           console.log('WebSocket message sent successfully:', value)
         } else {
           console.log('WebSocket not ready to send. Connected:', websocketConnected, 'ReadyState:', websocket?.readyState)
         }
       }
       
       // Web Audio API setup
       let audioContext = null
       let userOscillators = {} // Per-user oscillators
       let mainGainNode = null
       
       // User morse code visualizer setup
       let userCanvases = {} // Per-user canvases
       let userMorseSegments = {} // Per-user morse segments
       let userDrawingStates = {} // Per-user drawing states
       let globalAnimationId = null // Single animation loop for all users

       // Generate unique frequency for a user based on their username
       function getUserFrequency(userId) {
         if (userFrequencies[userId]) {
           return userFrequencies[userId]
         }

         // Simple hash function to convert string to number
         let hash = 0
         for (let i = 0; i < userId.length; i++) {
           const char = userId.charCodeAt(i)
           hash = ((hash << 5) - hash) + char
           hash = hash & hash // Convert to 32bit integer
         }

         // Convert hash to frequency between 220Hz and 880Hz
         const frequency = 220 + (Math.abs(hash) % 661) // 661 = 880 - 220 + 1
         userFrequencies[userId] = frequency

         console.log(`Generated frequency for ${userId}: ${frequency}Hz`)
         return frequency
       }
       
       // Initialize WebSocket on page load
       document.addEventListener('DOMContentLoaded', function() {
         initWebSocket()
       })
       
       // Initialize audio context (will be created on first user interaction)
       function initAudioContext() {
         if (!audioContext) {
           audioContext = new (window.AudioContext || window.webkitAudioContext)()
           mainGainNode = audioContext.createGain()
           mainGainNode.connect(audioContext.destination)
         }
       }
       
       
       // Reusable functions for mode behaviors
       function startBackgroundColor() {
         document.body.style.backgroundColor = '#006600'
       }
       
       function stopBackgroundColor() {
         document.body.style.backgroundColor = ''
       }
       
       function startAudio(userId = currentUserId) {
         if (!userOscillators[userId]) {
           initAudioContext()
           if (audioContext.state === 'suspended') {
             audioContext.resume()
           }

           // Create individual gain node for this user
           const userGainNode = audioContext.createGain()
           const volume = userId === currentUserId ? 0.3 : 0.2
           userGainNode.gain.setValueAtTime(volume, audioContext.currentTime)
           userGainNode.connect(mainGainNode)

           // Create oscillator for this user
           const oscillator = audioContext.createOscillator()
           oscillator.type = 'sine'
           const frequency = getUserFrequency(userId)
           oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime)
           oscillator.connect(userGainNode)
           oscillator.start()

           // Store both oscillator and gain node
           userOscillators[userId] = { oscillator, gainNode: userGainNode }
         }
       }
       
       function stopAudio(userId = currentUserId) {
         const userAudio = userOscillators[userId]
         if (userAudio) {
           try {
             // Quick volume fade-out to prevent clicking
             userAudio.gainNode.gain.setValueAtTime(userAudio.gainNode.gain.value, audioContext.currentTime)
             userAudio.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.01) // 10ms fade

             // Stop oscillator after fade completes
             setTimeout(() => {
               if (userOscillators[userId]) {
                 userAudio.oscillator.stop()
                 userAudio.oscillator.disconnect()
                 userAudio.gainNode.disconnect()
                 delete userOscillators[userId]
               }
             }, 15) // Slightly longer than fade duration
           } catch (e) {
             // Oscillator might already be stopped
             delete userOscillators[userId]
           }
         }
       }
       
       
       // Remote user visualization functions
       function handleRemoteSpacePress(userId) {
         console.log('Remote space press from:', userId)

         // Update user's morse visualization
         updateUserMorse(userId, true)

         // Audio effects for remote users (no background color change)
         startAudio(userId)
       }

       function handleRemoteSpaceRelease(userId) {
         console.log('Remote space release from:', userId)

         // Update user's morse visualization
         updateUserMorse(userId, false)

         // Stop remote audio effects
         stopAudio(userId)
       }


       // No mode switching needed
       

      const SPACE = 'Space'
      const DIT_KEY = 'Period' // . key
      const DAH_KEY = 'Minus' // - key
      const INPUT_KEY = 'KeyI' // i key
      const DIT_DURATION = 60 // milliseconds
      const DAH_DURATION = 180 // milliseconds (3x dit)
      const INTER_SYMBOL_GAP = 60 // Gap between dit/dah within a letter
      const LETTER_GAP = 180 // Gap between letters (3x dit)
      const WORD_GAP = 420 // Gap between words (7x dit)

      let ditTimeout = null
      let dahTimeout = null
      let ditActive = false
      let dahActive = false
      let morseInputActive = false
      let morseTransmitting = false

      // Morse code lookup table
      const MORSE_CODE = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
        'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--',
        '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..',
        '9': '----.', '0': '-----', '.': '.-.-.-', ',': '--..--', '?': '..--..',
        '/': '-..-.', ' ': ' '
      }

      // Space bar behavior based on current mode
      document.addEventListener('keydown', function (event) {
        // Handle input mode toggle - only open with 'i', not close
        if (event.code === INPUT_KEY && !event.repeat && !morseTransmitting && !morseInputActive) {
          event.preventDefault()
          toggleMorseInput()
          return
        }

        // If input is active, don't handle other keys (except within input field)
        if (morseInputActive) {
          return
        }

        if (event.code === SPACE && !event.repeat) {
          event.preventDefault() // Prevent default space bar behavior (page scrolling)
          handleSpacePress()
        } else if (event.code === DIT_KEY && !event.repeat && !ditActive) {
          event.preventDefault()
          handleDitPress()
        } else if (event.code === DAH_KEY && !event.repeat && !dahActive) {
          event.preventDefault()
          handleDahPress()
        }
      })

      document.addEventListener('keyup', function (event) {
        if (morseInputActive) return

        if (event.code === SPACE) {
          handleSpaceRelease()
        }
      })

      // Mobile/Mouse support: allow clicking anywhere on screen
      let isMousePressed = false

      // Mouse events for desktop
      document.addEventListener('mousedown', function(event) {
        if (isMousePressed) return // Prevent double-press
        isMousePressed = true
        event.preventDefault()
        handleSpacePress()
      })

      document.addEventListener('mouseup', function(event) {
        if (!isMousePressed) return
        isMousePressed = false
        event.preventDefault()
        handleSpaceRelease()
      })

      // Touch events for mobile
      document.addEventListener('touchstart', function(event) {
        event.preventDefault()
        handleSpacePress()
      })

      document.addEventListener('touchend', function(event) {
        event.preventDefault()
        handleSpaceRelease()
      })

      document.addEventListener('touchcancel', function(event) {
        event.preventDefault()
        handleSpaceRelease()
      })

       function handleSpacePress() {
         // Send WebSocket message for space press
         sendWebSocketMessage(1)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, true)
         }

         // Effects: background + audio
         startBackgroundColor()
         startAudio(currentUserId)
       }

       function handleSpaceRelease() {
         // Send WebSocket message for space release
         sendWebSocketMessage(0)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, false)
         }

         // Stop all effects
         stopBackgroundColor()
         stopAudio(currentUserId)
       }

       function handleDitPress() {
         // Fire and forget - ignore if already active
         if (ditActive) return

         ditActive = true

         // Send WebSocket message for dit press
         sendWebSocketMessage(1)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, true)
         }

         // Effects: background + audio
         startBackgroundColor()
         startAudio(currentUserId)

         // Auto-release after DIT_DURATION
         ditTimeout = setTimeout(() => {
           sendWebSocketMessage(0)
           if (currentUserId) {
             updateUserMorse(currentUserId, false)
           }
           stopBackgroundColor()
           stopAudio(currentUserId)
           ditTimeout = null
           ditActive = false
         }, DIT_DURATION)
       }

       function handleDahPress() {
         // Fire and forget - ignore if already active
         if (dahActive) return

         dahActive = true

         // Send WebSocket message for dah press
         sendWebSocketMessage(1)

         // Update current user's morse visualization
         if (currentUserId) {
           updateUserMorse(currentUserId, true)
         }

         // Effects: background + audio
         startBackgroundColor()
         startAudio(currentUserId)

         // Auto-release after DAH_DURATION
         dahTimeout = setTimeout(() => {
           sendWebSocketMessage(0)
           if (currentUserId) {
             updateUserMorse(currentUserId, false)
           }
           stopBackgroundColor()
           stopAudio(currentUserId)
           dahTimeout = null
           dahActive = false
         }, DAH_DURATION)
       }

       // Toggle morse code input
       function toggleMorseInput() {
         const container = document.getElementById('morseInputContainer')
         const input = document.getElementById('morseInput')

         morseInputActive = !morseInputActive

         if (morseInputActive) {
           container.classList.add('active')
           input.focus()
         } else {
           container.classList.remove('active')
           input.value = ''
         }
       }

       // Handle input field events
       document.addEventListener('DOMContentLoaded', function() {
         const input = document.getElementById('morseInput')

         input.addEventListener('keydown', function(event) {
           if (event.key === 'Enter') {
             event.preventDefault()
             const text = input.value.trim()
             if (text && !morseTransmitting) {
               transmitMorseCode(text)
             }
           } else if (event.key === 'Escape') {
             event.preventDefault()
             toggleMorseInput()
           }
         })
       })

       // Convert text to morse and transmit
       async function transmitMorseCode(text) {
         if (morseTransmitting) return

         morseTransmitting = true
         const upperText = text.toUpperCase()

         // Close input
         toggleMorseInput()

         for (let i = 0; i < upperText.length; i++) {
           const char = upperText[i]
           const morseSymbols = MORSE_CODE[char]

           if (!morseSymbols) continue // Skip unknown characters

           if (morseSymbols === ' ') {
             // Word gap (already includes letter gap from previous letter)
             await sleep(WORD_GAP - LETTER_GAP)
           } else {
             // Transmit each dit or dah
             for (let j = 0; j < morseSymbols.length; j++) {
               const symbol = morseSymbols[j]

               if (symbol === '.') {
                 await transmitDit()
               } else if (symbol === '-') {
                 await transmitDah()
               }

               // Gap between symbols within the same letter
               if (j < morseSymbols.length - 1) {
                 await sleep(INTER_SYMBOL_GAP)
               }
             }

             // Gap between letters
             if (i < upperText.length - 1 && upperText[i + 1] !== ' ') {
               await sleep(LETTER_GAP)
             }
           }
         }

         morseTransmitting = false
       }

       // Transmit a dit
       function transmitDit() {
         return new Promise((resolve) => {
           // Send WebSocket message
           sendWebSocketMessage(1)

           // Update visualization
           if (currentUserId) {
             updateUserMorse(currentUserId, true)
           }

           // Effects
           startBackgroundColor()
           startAudio(currentUserId)

           // Auto-release after DIT_DURATION
           setTimeout(() => {
             sendWebSocketMessage(0)
             if (currentUserId) {
               updateUserMorse(currentUserId, false)
             }
             stopBackgroundColor()
             stopAudio(currentUserId)
             resolve()
           }, DIT_DURATION)
         })
       }

       // Transmit a dah
       function transmitDah() {
         return new Promise((resolve) => {
           // Send WebSocket message
           sendWebSocketMessage(1)

           // Update visualization
           if (currentUserId) {
             updateUserMorse(currentUserId, true)
           }

           // Effects
           startBackgroundColor()
           startAudio(currentUserId)

           // Auto-release after DAH_DURATION
           setTimeout(() => {
             sendWebSocketMessage(0)
             if (currentUserId) {
               updateUserMorse(currentUserId, false)
             }
             stopBackgroundColor()
             stopAudio(currentUserId)
             resolve()
           }, DAH_DURATION)
         })
       }

       // Sleep utility
       function sleep(ms) {
         return new Promise(resolve => setTimeout(resolve, ms))
       }
    </script>
</body>
</html>
